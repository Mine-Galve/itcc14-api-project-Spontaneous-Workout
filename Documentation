Spontaneity Fit Navigation


Site: Xavier University 
Course: ITCC14-API-PROJECT - Building a RESTful API
Book: Spontaneity Fit: Backend API Lecture


Printed by:Mine GalveDate:Sunday, 16 November 2025, 10:54 PM








Spontaneity Fit - Complete Project Documentation
Table of Contents

Project Overview
Project Structure
Detailed File Explanations
Complete Application Flow
Key Technical Concepts
Presentation Guide


Project Overview
Project Name: Spontaneity Fit
Type: Full-Stack Web Application
Purpose: Instant workout generator that eliminates decision fatigue
Problem Solved: Many people struggle with workout monotony and don't know what exercises to do at the gym.
Solution: A RESTful API that generates randomized, customized workout routines based on user preferences (target area and available equipment).
Technology Stack:

Frontend: HTML, CSS, JavaScript
Backend: Node.js with Express.js
Database: MongoDB with Mongoose
Deployment: Render.com (Backend), MongoDB Atlas (Database)


Project Structure
/SpontaneityFit-API
  |-- /client              ← Frontend (what users see)
  |   |-- index.html       ← The webpage structure
  |   |-- style.css        ← Makes it look good
  |   |-- app.js           ← Handles button clicks and API calls
  |
  |-- /models              ← Database blueprints
  |   |-- Exercise.js      ← Defines what an exercise looks like
  |
  |-- .env                 ← Secret configuration (database password)
  |-- .gitignore           ← Tells Git what NOT to upload
  |-- db.js                ← Connects to MongoDB database
  |-- index.js             ← Main server (the brain of the backend)
  |-- seed.js              ← Populates database with exercises
  |-- seed-enhanced.js     ← Populates with MORE exercises + instructions
  |-- package.json         ← Lists all dependencies (libraries needed)

Detailed File Explanations
1. /client/index.html - The User Interface
Purpose: Creates the visual structure of your webpage
What it does:

Creates the title "Spontaneity Fit"
Creates dropdown menus for:

Target Area (Full Body, Legs, Push, Pull)
Equipment (Bodyweight, Dumbbells Only)


Creates the "Generate Workout" button
Creates a hidden results area that shows workouts

Key HTML Elements:
html<select id="focus">           <!-- Dropdown for target area -->
<select id="equipment">       <!-- Dropdown for equipment type -->
<button id="generateBtn">     <!-- Button to generate workout -->
<div id="result-area">        <!-- Where workouts appear -->
Analogy: The skeleton/structure of a house - it defines where everything goes.

2. /client/style.css - The Styling
Purpose: Makes the app look beautiful and professional
What it does:

Sets colors, fonts, and spacing
Makes the container centered with a white background
Styles the green "Generate Workout" button
Creates the workout card design with green left border
Adds difficulty badges (beginner = green, intermediate = yellow, advanced = red)
Makes the instruction dropdown collapsible

Key CSS Classes:
css.container          /* White box in center of page */
button              /* Green button styling */
li                  /* Individual exercise cards */
.difficulty         /* Color-coded difficulty badges */
.instructions       /* Collapsible instruction section */
Analogy: The paint, furniture, and decoration of a house - makes it look good.

3. /client/app.js - The Frontend Logic
Purpose: Handles user interactions and communicates with the backend API
Step-by-Step Flow:
Step 1: Wait for Button Click
javascriptgenerateBtn.addEventListener('click', async () => {
When user clicks "Generate Workout", this function runs
Step 2: Get User Choices
javascriptconst focus = document.getElementById('focus').value;
const equipment = document.getElementById('equipment').value;
Reads what the user selected (e.g., "legs" + "bodyweight")
Step 3: Update Button State
javascriptgenerateBtn.innerText = "Generating...";
generateBtn.disabled = true;
Shows user that something is happening
Step 4: Call the API
javascriptconst response = await fetch(`${API_URL}?focus=${focus}&equipment=${equipment}`);
Sends request to backend: "Give me leg bodyweight exercises"
Step 5: Process the Response
javascriptconst data = await response.json();
Converts the API response into JavaScript object
Step 6: Display the Workout
javascriptdata.exercises.forEach((exercise, index) => {
    // Creates HTML for each exercise
});
Loops through each exercise and displays it on the page
Step 7: Handle Errors
javascriptcatch (error) {
    alert("Could not get workout...");
}
Shows friendly error message if something goes wrong
Analogy: The electrical wiring in a house - makes buttons work and connects everything.

4. /models/Exercise.js - The Data Blueprint
Purpose: Defines the structure of an exercise in the database
Schema Definition:
javascriptconst ExerciseSchema = new mongoose.Schema({
  name: { type: String, required: true, trim: true },
  focus_tag: { type: String, required: true },
  equipment_tag: { type: String, required: true },
  instructions: { type: String, required: true },
  difficulty: { type: String, default: 'beginner' },
  musclesWorked: [{ type: String }]
});
Field Explanations:

name: Exercise name (e.g., "Push Up")
focus_tag: What it targets ("push", "pull", "legs", "full_body")
equipment_tag: What equipment needed ("bodyweight", "dumbbells_only")
instructions: Step-by-step how to do it
difficulty: Skill level ("beginner", "intermediate", "advanced")
musclesWorked: Array of muscles used (["chest", "triceps", "shoulders"])

Analogy: A blueprint/template - every exercise MUST follow this structure.

5. db.js - Database Connection
Purpose: Establishes connection to MongoDB database
How it Works:
javascriptconst connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log('MongoDB Connected successfully!');
  } catch (err) {
    console.error(`MongoDB Connection Error: ${err.message}`);
    process.exit(1);
  }
};
Step-by-step:

Reads the connection string from .env file (keeps password secret)
Attempts to connect to MongoDB Atlas (cloud database)
If successful: Prints "MongoDB Connected successfully!"
If fails: Shows error and stops the server

Analogy: The plumbing that connects your house to the city water supply.

6. .env - Secret Configuration
Purpose: Stores sensitive information (passwords, API keys)
Contents:
MONGO_URI=mongodb+srv://username:password@cluster...
Why it's important:

✅ Keeps database password secret
✅ Different settings for local vs. production
✅ NOT uploaded to GitHub (protected by .gitignore)

Analogy: The safe where you keep your house keys.

7. .gitignore - Protection
Purpose: Tells Git what NOT to upload to GitHub
Contents:
node_modules
.env
Why:

node_modules: Huge folder (thousands of files) - can be reinstalled
.env: Contains secrets - NEVER upload passwords to public GitHub

Analogy: A "Do Not Disturb" sign - keeps private things private.

8. index.js - The Main Server (MOST IMPORTANT)
Purpose: The heart of your backend - handles all API requests
Section 1: Setup & Imports
javascriptconst express = require('express');
const connectDB = require('./db');
const Exercise = require('./models/Exercise');

Imports all necessary tools
Express: Web server framework
connectDB: Function to connect to database
Exercise: Model for exercises

Section 2: Initialize
javascriptconnectDB();
const app = express();
app.use(cors());
app.use(express.json());

Connects to database
Creates Express app
CORS: Allows frontend to talk to backend
express.json(): Allows reading JSON data

Section 3: Serve Frontend
javascriptapp.use(express.static(path.join(__dirname, 'client')));
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'client', 'index.html'));
});

Serves static files (HTML, CSS, JS)
When someone visits /, send them index.html

Section 4: API Endpoint (THE MAIN FEATURE)
The Core Function:
javascriptapp.get('/api/v1/generate-workout', async (req, res) => {
What happens inside:
Step 1: Get user input
javascriptconst { focus, equipment } = req.query;
Reads URL parameters: ?focus=legs&equipment=bodyweight
Step 2: Build database filter
javascriptconst filter = {};
if (focus) filter.focus_tag = focus;
if (equipment) filter.equipment_tag = equipment;
Creates filter: "Find exercises where focus_tag=legs AND equipment_tag=bodyweight"
Step 3: Query database
javascriptconst exercises = await Exercise.aggregate([
  { $match: filter },
  { $sample: { size: 5 } }
]);

$match: Find exercises matching the filter
$sample: Randomly pick 5 exercises
This ensures variety - different workout every time!

Step 4: Check if exercises found
javascriptif (!exercises || exercises.length === 0) {
  return res.status(404).json({ msg: 'No exercises found...' });
}
If no exercises match, send error message
Step 5: Format the response
javascriptconst formattedExercises = exercises.map((ex) => {
  return {
    name: ex.name,
    sets: 3,
    reps: '10-12',
    instructions: ex.instructions,
    difficulty: ex.difficulty,
    musclesWorked: ex.musclesWorked
  };
});
Adds sets/reps to each exercise and provides defaults if data is missing
Step 6: Create workout title
javascriptconst routineTitle = `${focus || 'Full Body'} ${equipment || ''} Workout`.trim();
Creates title like: "Legs Bodyweight Workout"
Step 7: Send response
javascriptres.json({
  routine_title: routineTitle,
  exercises: formattedExercises,
});
Sends JSON back to frontend
Section 5: Start Server
javascriptconst PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
Starts server on port 3000 (local) or whatever Render assigns
Analogy: The restaurant kitchen - takes orders (requests) and prepares food (responses).

9. seed.js - Original Database Populator
Purpose: Adds initial exercises to database
How it Works:
javascriptconst sampleExercises = [
  { name: 'Push Up', focus_tag: 'push', equipment_tag: 'bodyweight' },
  // ... 5 more exercises
];

const importData = async () => {
  await connectDB();
  await Exercise.deleteMany();        // Clear old data
  await Exercise.insertMany(sampleExercises);  // Add new data
  console.log('Data Imported Successfully!');
};
Analogy: Stocking the warehouse with initial inventory.

10. seed-enhanced.js - Enhanced Database Populator
Purpose: Same as seed.js but with 30+ exercises, instructions, difficulty levels
Key Differences:

More exercises (30+ vs 6)
Includes step-by-step instructions
Includes difficulty levels
Includes muscles worked

Analogy: Upgraded warehouse with more detailed inventory.

11. package.json - Project Configuration
Purpose: Lists all dependencies and project info
Key Dependencies:
json{
  "dependencies": {
    "cors": "^2.8.5",         // Allows cross-origin requests
    "dotenv": "^17.2.3",      // Reads .env files
    "express": "^5.1.0",      // Web server framework
    "mongoose": "^8.19.4"     // MongoDB database library
  }
}
Analogy: Shopping list - tells npm install what to download.

Complete Application Flow
Frontend → Backend → Database → Backend → Frontend
1. USER CLICKS "Generate Workout"
   ↓
2. app.js reads dropdown selections
   (focus: "legs", equipment: "bodyweight")
   ↓
3. app.js sends HTTP request to API:
   GET /api/v1/generate-workout?focus=legs&equipment=bodyweight
   ↓
4. Render server receives request
   ↓
5. index.js processes the request:
   - Reads query parameters
   - Builds database filter
   ↓
6. index.js queries MongoDB:
   "Find exercises where focus_tag='legs' AND equipment_tag='bodyweight'"
   ↓
7. MongoDB searches through exercises collection
   ↓
8. MongoDB returns matching exercises
   ↓
9. index.js randomly selects 5 exercises
   ↓
10. index.js formats the data:
    - Adds sets (3)
    - Adds reps (10-12)
    - Includes instructions
    - Includes difficulty
    ↓
11. index.js sends JSON response back to frontend
    ↓
12. app.js receives the data
    ↓
13. app.js creates HTML for each exercise
    ↓
14. Browser displays the workout to user

Key Technical Concepts
1. REST API

REpresentational State Transfer
Way for frontend and backend to communicate
Uses HTTP methods (GET, POST, PUT, DELETE)
Your API: GET /api/v1/generate-workout

2. Full-Stack Application

Frontend: HTML, CSS, JavaScript (what users see)
Backend: Node.js + Express (server logic)
Database: MongoDB (stores exercise data)

3. Environment Variables

Keeps secrets safe (passwords, API keys)
Different values for local vs production
Stored in .env, read by dotenv package

4. Database Aggregation

$match: Filters exercises based on criteria
$sample: Randomly selects exercises
Ensures variety in workouts

5. CORS (Cross-Origin Resource Sharing)

Allows frontend to communicate with backend
Security feature in browsers
app.use(cors()) enables it

6. Asynchronous Programming

async/await syntax
Waits for database queries to complete
Prevents blocking the server
Non-blocking I/O operations

7. MVC Pattern (Model-View-Controller)

Model: Exercise.js (data structure)
View: HTML/CSS (user interface)
Controller: index.js (business logic)


Benefits of This Project
When presenting, highlight these advantages:
✅ Solves real problem: Workout decision fatigue
✅ Full-stack: Frontend + Backend + Database
✅ Deployed live: Anyone can access via URL
✅ Random generation: Variety in every workout
✅ Scalable: Easy to add more exercises
✅ User-friendly: Simple, clean interface
✅ Educational: Step-by-step instructions
✅ Professional: Uses industry-standard tools

Presentation Guide
Opening Statement
"Spontaneity Fit is a full-stack workout generator that eliminates decision fatigue. Users select their focus area and available equipment, and the API instantly generates a randomized workout by querying a MongoDB database with over 30 exercises. Each exercise includes step-by-step instructions, difficulty levels, and targeted muscle groups."
Technical Architecture
"The frontend is built with HTML, CSS, and JavaScript for the user interface. The backend uses Node.js with Express.js to create a RESTful API. MongoDB stores all exercise data with Mongoose as the ODM (Object Data Modeling) library. The application is deployed on Render.com with MongoDB Atlas hosting the database in the cloud."
Key Feature Explanation
"The key feature is the random workout generation using MongoDB's aggregation pipeline. When a user selects their preferences, the API filters exercises using the $match operator based on focus area and equipment. Then, the $sample operator randomly selects 5 exercises from the filtered results, ensuring variety in every workout session."
Code Flow Demonstration

Show the frontend interface
Explain dropdown selections
Open browser DevTools Network tab
Generate a workout and show the API call
Show the JSON response
Explain how JavaScript creates the HTML elements

Technical Challenges & Solutions
Challenge 1: Cold Starts on Render

Problem: Free tier servers sleep after inactivity
Solution: Implemented UptimeRobot to ping server every 5 minutes

Challenge 2: Database Seeding

Problem: Empty database after deployment
Solution: Created seed scripts to populate with exercises

Challenge 3: CORS Errors

Problem: Frontend couldn't communicate with backend
Solution: Added CORS middleware to Express server

Future Enhancements

User accounts and saved workouts
Custom exercise creation
Workout history tracking
Timer functionality
Video demonstrations
Social sharing features
Mobile app version


Common Questions & Answers
Q: Why use MongoDB instead of SQL?
A: MongoDB's flexible schema is perfect for exercises that may have varying attributes. It's also easier to add new fields without database migrations.
Q: How does the random selection work?
A: We use MongoDB's $sample aggregation operator which randomly selects documents from the collection, ensuring different workouts each time.
Q: Why separate frontend and backend?
A: This architecture allows the API to serve multiple clients (web, mobile app, etc.) and makes the code more maintainable.
Q: Can this work offline?
A: The frontend can be cached, but the API requires internet to query the database. A fully offline version would need local storage.
Q: How scalable is this?
A: Very scalable! MongoDB Atlas can handle millions of documents, and Render can auto-scale based on traffic.

Running the Project
Locally:
bash# Install dependencies
npm install

# Update .env with your MongoDB URI
MONGO_URI=your_mongodb_connection_string

# Seed the database
node seed-enhanced.js

# Start the server
node index.js

# Access at: http://localhost:3000
Live Deployment:

Frontend + Backend: https://spontaneity-fit-api.onrender.com
Database: MongoDB Atlas (cloud)
Monitoring: UptimeRobot (keeps server awake)


Project Statistics

Total Lines of Code: ~500+
Total Exercises: 30+
API Endpoints: 1 main endpoint
Dependencies: 4 main packages
Response Time: ~200-300ms average
Deployment Platform: Render.com (free tier)


Credits & Resources
Technologies Used:

Node.js - JavaScript runtime
Express.js - Web framework
MongoDB - NoSQL database
Mongoose - MongoDB ODM
Render - Deployment platform
MongoDB Atlas - Cloud database

Learning Resources:

Express Documentation: https://expressjs.com/
MongoDB Documentation: https://docs.mongodb.com/
Mongoose Guide: https://mongoosejs.com/docs/guide.html
Render Deployment: https://render.com/docs


Conclusion
Spontaneity Fit demonstrates a complete understanding of full-stack web development, from frontend design to backend API development and database management. The project successfully implements RESTful principles, asynchronous programming, and cloud deployment, making it a comprehensive showcase of modern web development skills.
